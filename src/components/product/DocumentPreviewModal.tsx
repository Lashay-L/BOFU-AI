import React, { useState, useRef } from 'react';
import { X, FileText, Link2, Download, Copy, CheckCircle, ExternalLink, Calendar, User, FileType, Hash, RefreshCw, AlertCircle, Info } from 'lucide-react';
import { ProductDocument } from '../../types/product/types';
import { supabase } from '../../lib/supabase';

interface DocumentPreviewModalProps {
  document: ProductDocument | null;
  isOpen: boolean;
  onClose: () => void;
}

const DocumentPreviewModal: React.FC<DocumentPreviewModalProps> = ({ document, isOpen, onClose }) => {
  const [copyStatus, setCopyStatus] = useState<'idle' | 'copied'>('idle');
  const [isReExtracting, setIsReExtracting] = useState<boolean>(false);
  const [isDownloading, setIsDownloading] = useState<boolean>(false);
  const [fullContent, setFullContent] = useState<string>('');
  const [reExtractionError, setReExtractionError] = useState<string>('');
  const [downloadStatus, setDownloadStatus] = useState<string>('');
  const contentRef = useRef<HTMLPreElement>(null);

  // Debug: Log document data when modal opens
  React.useEffect(() => {
    if (document && isOpen) {
      console.log('üìÑ Document Preview Modal Data:', {
        id: document.id,
        file_name: document.file_name,
        document_type: document.document_type,
        storage_path: document.storage_path,
        file_url: document.file_url,
        source_url: document.source_url,
        status: document.status,
        hasExtractedText: !!document.extracted_text,
        extractedTextLength: document.extracted_text?.length || 0,
        // Log all fields to see what's available
        allFields: Object.keys(document)
      });
      
      // Reset states when document changes
      setFullContent('');
      setReExtractionError('');
      setDownloadStatus('');
      setCopyStatus('idle');
    }
  }, [document, isOpen]);

  // Keyboard shortcuts
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Only handle if modal is open and document exists
      if (!isOpen || !document) return;
      
      // Escape to close
      if (event.key === 'Escape') {
        onClose();
        return;
      }

      const currentContent = fullContent || document.extracted_text;

      // Ctrl/Cmd + C to copy text
      if ((event.ctrlKey || event.metaKey) && event.key === 'c' && !event.defaultPrevented && currentContent) {
        // Only trigger if not in an input field
        const activeElement = window.document.activeElement;
        const isInInputField = activeElement?.tagName === 'INPUT' || 
                              activeElement?.tagName === 'TEXTAREA' || 
                              activeElement?.getAttribute('contenteditable') === 'true';
        
        if (!isInInputField) {
          event.preventDefault();
          handleCopy();
        }
      }

      // Ctrl/Cmd + D to download original file
      if ((event.ctrlKey || event.metaKey) && event.key === 'd' && document.storage_path && !isDownloading) {
        event.preventDefault();
        handleDownloadOriginal();
      }
    };

    if (isOpen) {
      window.addEventListener('keydown', handleKeyDown);
    }

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen, onClose, fullContent, document?.storage_path, document?.extracted_text, isDownloading]);

  // Move ALL function definitions here, before conditional return
  const handleCopy = async () => {
    if (!document) return;
    const contentToCopy = fullContent || document.extracted_text;
    if (contentToCopy) {
      try {
        await navigator.clipboard.writeText(contentToCopy);
        setCopyStatus('copied');
        setTimeout(() => setCopyStatus('idle'), 2000);
      } catch (err) {
        console.error('Failed to copy text:', err);
      }
    }
  };

  const handleDownloadText = () => {
    if (!document) return;
    const contentToDownload = fullContent || document.extracted_text;
    if (contentToDownload) {
      // Create a comprehensive formatted document
      const documentHeader = `${'='.repeat(80)}
${document.file_name.toUpperCase()}
${'='.repeat(80)}

üìÑ DOCUMENT INFORMATION
${'-'.repeat(40)}
‚Ä¢ File Name: ${document.file_name}
‚Ä¢ Document Type: ${document.document_type}
‚Ä¢ Status: ${document.status}
‚Ä¢ Added: ${formatDate(document.created_at)}
‚Ä¢ Size: ${contentToDownload.length.toLocaleString()} characters
‚Ä¢ Word Count: ~${Math.round(contentToDownload.split(' ').length)} words
${document.source_url ? `‚Ä¢ Source URL: ${document.source_url}` : ''}
${document.content_hash ? `‚Ä¢ Content Hash: ${document.content_hash}` : ''}

${'='.repeat(80)}
DOCUMENT CONTENT
${'='.repeat(80)}

`;

      const documentFooter = `

${'='.repeat(80)}
END OF DOCUMENT
${'='.repeat(80)}

Generated by BOFU AI Document Processor
Export Date: ${new Date().toLocaleString()}
Document ID: ${document.id}
${document.openai_vsf_id ? `Vector Store File ID: ${document.openai_vsf_id}` : ''}
`;

      const fullFormattedContent = documentHeader + contentToDownload + documentFooter;
      
      const blob = new Blob([fullFormattedContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = window.document.createElement('a');
      a.href = url;
      
      // Create a better filename with timestamp
      const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
      const baseName = document.file_name.replace(/\.[^/.]+$/, ''); // Remove extension
      a.download = `${baseName}_extracted_${timestamp}.txt`;
      
      window.document.body.appendChild(a);
      a.click();
      window.document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('üì• Downloaded formatted text document:', a.download);
    }
  };

  const handleDownloadOriginal = async () => {
    if (!document) return;
    setIsDownloading(true);
    setDownloadStatus('Preparing download...');
    
    try {
      let downloadUrl = '';
      const fileName = document.file_name;

      // Check if it's a Supabase storage file
      if (document.storage_path) {
        setDownloadStatus('Locating file in storage...');
        console.log('Attempting to download from storage_path:', document.storage_path);
        
        // Try different bucket names that might be used
        const possibleBuckets = ['productdocuments', 'product_documents', 'documents', 'files', 'product-documents'];
        let success = false;
        
        for (const bucketName of possibleBuckets) {
          try {
            setDownloadStatus(`Checking ${bucketName} bucket...`);
            
            // Get the public URL from Supabase storage
            const { data } = supabase.storage
              .from(bucketName)
              .getPublicUrl(document.storage_path);
            
            if (data.publicUrl) {
              // Test if the URL is accessible
              const testResponse = await fetch(data.publicUrl, { method: 'HEAD' });
              if (testResponse.ok) {
                downloadUrl = data.publicUrl;
                success = true;
                console.log(`Found file in bucket: ${bucketName}`);
                setDownloadStatus(`Found file in ${bucketName} bucket`);
                break;
              }
            }
          } catch (bucketError) {
            console.log(`Bucket ${bucketName} failed:`, bucketError);
            continue;
          }
        }
        
        // If public URL doesn't work, try signed URLs
        if (!success) {
          setDownloadStatus('Generating secure access link...');
          for (const bucketName of possibleBuckets) {
            try {
              const { data: signedUrlData, error } = await supabase.storage
                .from(bucketName)
                .createSignedUrl(document.storage_path, 60); // 60 seconds expiry
              
              if (signedUrlData && !error) {
                downloadUrl = signedUrlData.signedUrl;
                success = true;
                console.log(`Got signed URL from bucket: ${bucketName}`);
                setDownloadStatus(`Generated secure link from ${bucketName}`);
                break;
              }
            } catch (signedError) {
              console.log(`Signed URL from ${bucketName} failed:`, signedError);
              continue;
            }
          }
        }
        
        if (!success) {
          throw new Error('File not found in any storage bucket. Storage path: ' + document.storage_path);
        }
      } else if (document.file_url) {
        // Use the direct file URL
        setDownloadStatus('Using direct file_url...');
        console.log('Using direct file_url:', document.file_url);
        downloadUrl = document.file_url;
      } else {
        throw new Error('No file URL or storage path available for this document');
      }

      setDownloadStatus('Downloading file...');
      console.log('Downloading from URL:', downloadUrl);

      // Download the file with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 seconds timeout
      
      const response = await fetch(downloadUrl, {
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
      }

      const blob = await response.blob();
      console.log('Downloaded blob size:', blob.size, 'bytes');
      
      setDownloadStatus('Preparing file...');
      
      const url = URL.createObjectURL(blob);
      const a = window.document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.target = '_blank';
      window.document.body.appendChild(a);
      a.click();
      window.document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setDownloadStatus('Download completed!');
      console.log('‚úÖ Successfully downloaded original file:', fileName);
      
      // Clear success message after 3 seconds
      setTimeout(() => setDownloadStatus(''), 3000);

    } catch (error) {
      console.error('‚ùå Download failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      
      if (errorMessage.includes('aborted')) {
        setDownloadStatus('Download timed out. File may be too large.');
      } else if (errorMessage.includes('Failed to fetch') || errorMessage.includes('HTTP error')) {
        setDownloadStatus('Unable to access file. It may have been moved or deleted.');
      } else {
        setDownloadStatus(`Download failed: ${errorMessage}`);
      }
      
      // Clear error message after 5 seconds
      setTimeout(() => setDownloadStatus(''), 5000);
    } finally {
      setIsDownloading(false);
    }
  };

  // CONDITIONAL RETURN MOVED TO AFTER ALL HOOKS AND FUNCTION DEFINITIONS
  if (!isOpen || !document) return null;

  const handleReExtractContent = async () => {
    if (!document.storage_path && !document.file_url && !document.source_url) {
      setReExtractionError('No file source available for re-extraction');
      return;
    }
    
    setIsReExtracting(true);
    setReExtractionError('');
    
    try {
      let fileUrl = '';
      let extractionMethod = 'Unknown';
      
      // Priority: storage_path > file_url > source_url
      if (document.storage_path) {
        extractionMethod = 'Supabase Storage';
        console.log('üîç Attempting re-extraction from storage_path:', document.storage_path);
        
        // Try different bucket names that might be used
        const possibleBuckets = ['productdocuments', 'product_documents', 'documents', 'files', 'product-documents'];
        let success = false;
        
        for (const bucketName of possibleBuckets) {
          try {
            const { data } = supabase.storage
              .from(bucketName)
              .getPublicUrl(document.storage_path);
            
            if (data.publicUrl) {
              // Test if the URL is accessible
              const testResponse = await fetch(data.publicUrl, { method: 'HEAD' });
              if (testResponse.ok) {
                fileUrl = data.publicUrl;
                success = true;
                console.log(`‚úÖ Found file in bucket: ${bucketName}`);
                break;
              }
            }
          } catch (bucketError) {
            console.log(`‚ùå Bucket ${bucketName} failed:`, bucketError);
            continue;
          }
        }
        
        // If public URL doesn't work, try signed URLs
        if (!success) {
          for (const bucketName of possibleBuckets) {
            try {
              const { data: signedUrlData, error } = await supabase.storage
                .from(bucketName)
                .createSignedUrl(document.storage_path, 300); // 5 minutes expiry
              
              if (signedUrlData && !error) {
                fileUrl = signedUrlData.signedUrl;
                success = true;
                console.log(`‚úÖ Got signed URL from bucket: ${bucketName}`);
                break;
              }
            } catch (signedError) {
              console.log(`‚ùå Signed URL from ${bucketName} failed:`, signedError);
              continue;
            }
          }
        }
        
        if (!success) {
          throw new Error('File not found in any storage bucket: ' + document.storage_path);
        }
      } else if (document.file_url) {
        extractionMethod = 'Direct File URL';
        console.log('üîç Attempting re-extraction from file_url:', document.file_url);
        fileUrl = document.file_url;
      } else if (document.source_url) {
        extractionMethod = 'Source URL';
        console.log('üîç Attempting re-extraction from source_url:', document.source_url);
        fileUrl = document.source_url;
      }

      if (!fileUrl) {
        throw new Error('No valid file URL found for re-extraction');
      }

      console.log(`üì• Fetching file from ${extractionMethod}:`, fileUrl);

      // Fetch the original file with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
      
      const response = await fetch(fileUrl, {
        signal: controller.signal,
        headers: {
          'Accept': '*/*',
        }
      });
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch file (${response.status}): ${response.statusText}`);
      }
      
      const blob = await response.blob();
      console.log('üì¶ Downloaded blob - size:', blob.size, 'bytes, type:', blob.type);
      
      // Determine file type and extract content accordingly
      const fileType = blob.type || document.document_type?.toLowerCase() || '';
      const fileName = document.file_name.toLowerCase();
      
      if (fileType.includes('text') || fileName.endsWith('.txt') || fileName.endsWith('.md')) {
        console.log('üìù Processing as text file');
        const text = await blob.text();
        if (text.trim().length === 0) {
          throw new Error('File appears to be empty or contains no readable text');
        }
        setFullContent(text);
        setReExtractionError('');
        console.log(`‚úÖ Successfully extracted ${text.length} characters from text file`);
      } else if (fileType.includes('pdf') || fileName.endsWith('.pdf')) {
        // For PDFs, we'll provide guidance rather than attempting complex extraction
        setReExtractionError('PDF text extraction requires specialized processing. The current extracted text is what was processed during upload. For complete content, please download the original PDF file.');
        console.log('‚ÑπÔ∏è PDF re-extraction not supported - directed user to download');
      } else if (fileType.includes('word') || fileName.endsWith('.docx') || fileName.endsWith('.doc')) {
        setReExtractionError('Word document re-extraction requires specialized processing. The current extracted text is what was processed during upload. For complete content, please download the original file.');
        console.log('‚ÑπÔ∏è Word document re-extraction not supported - directed user to download');
      } else if (fileType.includes('html') || fileName.endsWith('.html') || fileName.endsWith('.htm')) {
        console.log('üåê Processing as HTML file');
        const htmlText = await blob.text();
        // Basic HTML text extraction (strip tags)
        const tempDiv = window.document.createElement('div');
        tempDiv.innerHTML = htmlText;
        const extractedText = tempDiv.textContent || tempDiv.innerText || '';
        if (extractedText.trim().length === 0) {
          throw new Error('No readable text found in HTML file');
        }
        setFullContent(extractedText);
        setReExtractionError('');
        console.log(`‚úÖ Successfully extracted ${extractedText.length} characters from HTML file`);
      } else {
        throw new Error(`Re-extraction not supported for file type: ${fileType || 'unknown'}. Please download the original file for complete content.`);
      }
    } catch (error) {
      console.error('‚ùå Re-extraction failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      
      if (errorMessage.includes('aborted')) {
        setReExtractionError('Re-extraction timed out. The file may be too large or the source is slow to respond. Please try downloading the original file instead.');
      } else if (errorMessage.includes('Failed to fetch')) {
        setReExtractionError('Unable to access the file source. It may have been moved or require authentication. Please try downloading the original file instead.');
      } else {
        setReExtractionError(errorMessage);
      }
    } finally {
      setIsReExtracting(false);
    }
  };

  const handleExternalLink = () => {
    if (document.source_url) {
      window.open(document.source_url, '_blank');
    }
  };

  const getDocumentIcon = () => {
    const type = document.document_type?.toLowerCase();
    switch (type) {
      case 'pdf':
        return <FileText className="w-5 h-5 text-red-400" />;
      case 'docx':
      case 'doc':
        return <FileText className="w-5 h-5 text-blue-400" />;
      case 'pptx':
        return <FileText className="w-5 h-5 text-orange-400" />;
      case 'gdoc':
      case 'google_doc':
        return <Link2 className="w-5 h-5 text-green-400" />;
      case 'blog_link':
      case 'link':
        return <Link2 className="w-5 h-5 text-cyan-400" />;
      default:
        return <FileText className="w-5 h-5 text-gray-400" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status.toLowerCase()) {
      case 'completed':
        return 'text-green-400 bg-green-500';
      case 'processing':
        return 'text-blue-400 bg-blue-500';
      case 'pending':
        return 'text-yellow-400 bg-yellow-500';
      case 'failed':
        return 'text-red-400 bg-red-500';
      default:
        return 'text-gray-400 bg-gray-500';
    }
  };

  const formatDate = (dateString: string) => {
    try {
      return new Date(dateString).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch {
      return dateString;
    }
  };

  const formatText = (text: string) => {
    // Split by paragraphs and format for better readability
    return text.split('\n\n').map((paragraph, index) => (
      <p key={index} className="mb-4 leading-relaxed">
        {paragraph.trim()}
      </p>
    ));
  };

  const handleDownloadFromSource = async () => {
    if (!document.source_url) return;
    
    setIsDownloading(true);
    try {
      console.log('üîó Attempting to download from source URL:', document.source_url);
      
      // Try to fetch the content from the source URL
      const response = await fetch(document.source_url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
      }

      const blob = await response.blob();
      console.log('üì¶ Downloaded blob from source - size:', blob.size, 'bytes, type:', blob.type);
      
      const url = URL.createObjectURL(blob);
      const a = window.document.createElement('a');
      a.href = url;
      
      // Try to get filename from source URL or use document name
      let fileName = document.file_name;
      try {
        const urlObj = new URL(document.source_url);
        const pathParts = urlObj.pathname.split('/');
        const lastPart = pathParts[pathParts.length - 1];
        if (lastPart && lastPart.includes('.')) {
          fileName = lastPart;
        }
      } catch (e) {
        // Use original filename if URL parsing fails
      }
      
      a.download = fileName;
      a.target = '_blank';
      window.document.body.appendChild(a);
      a.click();
      window.document.body.removeChild(a);
      URL.revokeObjectURL(url);

      console.log('‚úÖ Successfully downloaded from source URL');

    } catch (error) {
      console.error('‚ùå Failed to download from source URL:', error);
      alert(`Failed to download from source URL: ${error instanceof Error ? error.message : 'Unknown error'}. The source may not allow direct downloads.`);
    } finally {
      setIsDownloading(false);
    }
  };

  const currentContent = fullContent || document.extracted_text;
  const isContentTruncated = document.extracted_text && document.extracted_text.length > 0 && 
    (document.extracted_text.length < 500 || 
     !document.extracted_text.includes('\n\n') ||
     document.extracted_text.endsWith('...'));

  const hasOriginalFile = document.storage_path || document.file_url;
  const hasSourceUrl = document.source_url && document.source_url !== document.file_url;

  return (
    <div className="fixed inset-0 bg-black backdrop-blur-sm z-50 flex items-center justify-center p-4">
      <div className="bg-secondary-900 rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] flex flex-col border border-secondary-700">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-secondary-700 bg-secondary-900">
          <div className="flex items-center space-x-3">
            {getDocumentIcon()}
            <div>
              <h2 className="text-xl font-semibold text-white truncate max-w-md" title={document.file_name}>
                {document.file_name}
              </h2>
              <div className="flex items-center space-x-4 mt-1">
                <span className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(document.status)}`}>
                  {document.status}
                </span>
                <span className="text-xs text-gray-400 flex items-center">
                  <FileType className="w-3 h-3 mr-1" />
                  {document.document_type}
                </span>
                {isContentTruncated && (
                  <span className="text-xs text-yellow-400 flex items-center">
                    <AlertCircle className="w-3 h-3 mr-1" />
                    Content may be truncated
                  </span>
                )}
              </div>
            </div>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-secondary-800 rounded-lg transition-colors"
          >
            <X className="w-5 h-5 text-gray-400" />
          </button>
        </div>

        {/* Document Metadata */}
        <div className="px-6 py-4 bg-secondary-800 border-b border-secondary-700">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
            <div className="flex items-center space-x-2 text-gray-300">
              <Calendar className="w-4 h-4 text-gray-400" />
              <span>Added: {formatDate(document.created_at)}</span>
            </div>
            <div className="flex items-center space-x-2 text-gray-300">
              <User className="w-4 h-4 text-gray-400" />
              <span>Size: {currentContent ? `${Math.round(currentContent.length / 1000)}k chars` : 'N/A'}</span>
            </div>
            {document.content_hash && (
              <div className="flex items-center space-x-2 text-gray-300">
                <Hash className="w-4 h-4 text-gray-400" />
                <span className="font-mono text-xs truncate">{document.content_hash.substring(0, 8)}...</span>
              </div>
            )}
          </div>
        </div>

        {/* Enhanced Action Bar - Made completely non-transparent */}
        <div className="px-6 py-3 bg-secondary-800 border-b border-secondary-700">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2 flex-wrap gap-2">
              {currentContent && (
                <>
                  <button
                    onClick={handleCopy}
                    className="px-3 py-1.5 bg-primary-600 hover:bg-primary-700 text-white rounded-lg transition-colors flex items-center text-sm"
                  >
                    {copyStatus === 'copied' ? (
                      <CheckCircle className="w-4 h-4 mr-1.5" />
                    ) : (
                      <Copy className="w-4 h-4 mr-1.5" />
                    )}
                    {copyStatus === 'copied' ? 'Copied!' : 'Copy Text'}
                  </button>
                  <button
                    onClick={handleDownloadText}
                    className="px-3 py-1.5 bg-secondary-700 hover:bg-secondary-600 text-gray-300 rounded-lg transition-colors flex items-center text-sm"
                  >
                    <Download className="w-4 h-4 mr-1.5" />
                    Download Text Only
                  </button>
                </>
              )}
              {hasOriginalFile && (
                <button
                  onClick={handleDownloadOriginal}
                  disabled={isDownloading}
                  className="px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors flex items-center text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Download className={`w-4 h-4 mr-1.5 ${isDownloading ? 'animate-spin' : ''}`} />
                  {isDownloading ? 'Downloading...' : 'Download Original File'}
                </button>
              )}
              {hasSourceUrl && (
                <button
                  onClick={handleDownloadFromSource}
                  disabled={isDownloading}
                  className="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors flex items-center text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Download className={`w-4 h-4 mr-1.5 ${isDownloading ? 'animate-spin' : ''}`} />
                  {isDownloading ? 'Downloading...' : 'Download from Source'}
                </button>
              )}
              {document.source_url && (
                <button
                  onClick={handleExternalLink}
                  className="px-3 py-1.5 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg transition-colors flex items-center text-sm"
                >
                  <ExternalLink className="w-4 h-4 mr-1.5" />
                  Open Original Link
                </button>
              )}
              {isContentTruncated && hasOriginalFile && (
                <button
                  onClick={handleReExtractContent}
                  disabled={isReExtracting}
                  className="px-3 py-1.5 bg-yellow-600 hover:bg-yellow-700 text-white rounded-lg transition-colors flex items-center text-sm disabled:opacity-50"
                >
                  <RefreshCw className={`w-4 h-4 mr-1.5 ${isReExtracting ? 'animate-spin' : ''}`} />
                  Re-extract Full Content
                </button>
              )}
            </div>
            <div className="text-xs text-gray-400">
              {currentContent ? 
                `${currentContent.split(' ').length} words ‚Ä¢ ${currentContent.split('\n').length} lines` 
                : 'No content available'
              }
            </div>
          </div>
        </div>

        {/* Main Content Area - Made non-transparent and scrollable */}
        <div className="flex-1 flex flex-col overflow-hidden bg-secondary-900">
          {/* Content Warning for Truncated Content */}
          {isContentTruncated && (
            <div className="px-6 py-3 bg-yellow-600 border-b border-yellow-500">
              <div className="flex items-center space-x-2 text-white text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>
                  This document preview shows truncated content. Use the "Download Original File" button to get the complete document.
                </span>
              </div>
            </div>
          )}

          {/* Download Status Panel */}
          {downloadStatus && (
            <div className={`px-6 py-3 border-b ${
              downloadStatus.includes('failed') || downloadStatus.includes('error') || downloadStatus.includes('timed out') 
                ? 'bg-red-600 border-red-500 text-white'
                : 'bg-blue-600 border-blue-500 text-white'
            }`}>
              <div className="flex items-center space-x-2 text-sm">
                <Info className="w-4 h-4" />
                <span>{downloadStatus}</span>
              </div>
            </div>
          )}

          {/* Re-extraction Error Panel */}
          {reExtractionError && (
            <div className="px-6 py-3 bg-red-600 border-b border-red-500">
              <div className="flex items-center space-x-2 text-white text-sm">
                <AlertCircle className="w-4 h-4" />
                <span>{reExtractionError}</span>
              </div>
            </div>
          )}

          {/* Document Content - Main scrollable area */}
          <div className="flex-1 overflow-y-auto p-6 bg-secondary-900">
            {currentContent ? (
              <div className="bg-secondary-800 rounded-lg p-4 border border-secondary-700">
                <pre 
                  ref={contentRef}
                  className="whitespace-pre-wrap text-sm text-gray-300 leading-relaxed font-mono"
                  style={{ fontFamily: 'ui-monospace, SFMono-Regular, "SF Mono", Monaco, Consolas, "Liberation Mono", "Courier New", monospace' }}
                >
                  {currentContent}
                </pre>
              </div>
            ) : (
              <div className="bg-secondary-800 rounded-lg p-8 border border-secondary-700 text-center">
                <FileText className="w-12 h-12 text-gray-500 mx-auto mb-4" />
                <p className="text-gray-400 mb-4">No text content available for preview</p>
                {hasOriginalFile && (
                  <button
                    onClick={handleDownloadOriginal}
                    disabled={isDownloading}
                    className="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg transition-colors disabled:opacity-50"
                  >
                    <Download className={`w-4 h-4 mr-2 inline ${isDownloading ? 'animate-spin' : ''}`} />
                    {isDownloading ? 'Downloading...' : 'Download Original File'}
                  </button>
                )}
                {hasSourceUrl && (
                  <button
                    onClick={handleDownloadFromSource}
                    disabled={isDownloading}
                    className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors disabled:opacity-50 ml-2"
                  >
                    <Download className={`w-4 h-4 mr-2 inline ${isDownloading ? 'animate-spin' : ''}`} />
                    {isDownloading ? 'Downloading...' : 'Download from Source'}
                  </button>
                )}
              </div>
            )}
          </div>
        </div>

        {/* Footer - Made non-transparent */}
        <div className="px-6 py-3 bg-secondary-800 border-t border-secondary-700 text-xs text-gray-400">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <span>Document ID: {document.id}</span>
              {document.storage_path && (
                <span>Storage: {document.storage_path.split('/').pop()}</span>
              )}
            </div>
            <div className="flex items-center space-x-4">
              {document.openai_vsf_id && (
                <span>
                  Vector Store: {document.openai_vsf_id.substring(0, 8)}...
                </span>
              )}
              <div className="flex items-center space-x-3 text-gray-500">
                <span>‚å®Ô∏è Shortcuts: Esc to close, Ctrl+C to copy, Ctrl+D to download</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DocumentPreviewModal; 